-- REVIEW 4
-- DDL (DATA DEFINITION LANGUAGE)
/*
RDBMS는 2차원의 테이블형식으로 데이터 관리 -> 객체(OBJECT) -> 스키마(SCHEMA) : 테이블 구조(정형화)

TABLE: 물리적인 메모리 공간 확보
VIEW : 논리적인 테이블
SEQUENCE (객체)
INDEX

-- CONSTRAINT (PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK)
-- 데이터의 무결성 유지, 데이터의 중복을 피할 수 있음
[기본구문] DEFAULT, CONSTRAINT 순서도 중요!
CREATE TABLE TABLE_NAME (
    COLUMN_NAME DATATYPE [DEFAULT EXPR] [COLUMN_CONSTRAINT],
    COLUMN_NAME DATATYPE [DEFAULT EXPR] [COLUMN_CONSTRAINT],
    ...
    [TABLE_CONSTRAINT]
);

-- INSERT
INSERT INTO TABLE_NAME(COLUMNS) VALUES(?, ?, ?, ?) ;
*/
-- DROP TABLE TEST01;
CREATE TABLE TEST01(
    ID         NUMBER(5),
    NAME       VARCHAR2(50),
    ADDRESS    VARCHAR2(50),
    REGDATE    DATE DEFAULT SYSDATE
);

-- 묵시적인 NULL > DEFAULT 옵션 수행
INSERT INTO TEST01(ID, NAME, ADDRESS)
VALUES(100, '홍길동', '서울');

-- DEFAULT는 묵시적인 NULL일 때 할당되는 것이고, 명시적인 NULL이 들어가게 되면 DEFAULT VALUE 가 아닌 NULL이 들어감
INSERT INTO TEST01
VALUES(100, '홍길동', '서울', NULL);

-- 명시적인 DEFAULT > DEFAULT 옵션 수행
INSERT INTO TEST01
VALUES(100, '홍길동', '서울', DEFAULT);

SELECT  *
FROM    TEST01;

-- NOT NULL
-- TABEL LEVEL의 CONSTRAINT를 할 수 있음
-- DROP TABLE TEST_NN;

-- UNIQUE
CREATE TABLE TEST_NN(
    ID      VARCHAR2(50)    UNIQUE,
    PWD     VARCHAR2(50)
);
INSERT INTO TEST_NN VALUES('GDKIM','GDKIM');
INSERT INTO TEST_NN VALUES(NULL, 'GDKIM');
SELECT  *
FROM    TEST_NN;

-- PRIMARY KEY: 테이블 당 1개만 가능
-- NOT NULL + UNIQUE
-- 두개 이상의 COLUMNS를 COMPOSITE 해서 PK로 잡고 싶은 경우 TABLE LEVEL CONSTRAINT로 처리
-- DROP TABLE TEST_PK;
CREATE TABLE TEST_PK(
    ID      VARCHAR2(50),
    NAME    VARCHAR2(50),
    PRIMARY KEY(ID, NAME)
);
INSERT INTO TEST_PK
VALUES ('GDKIM','GDKIM');

INSERT INTO TEST_PK
VALUES('JSLIM', '홍길동');

SELECT  *
FROM    TEST_PK;
-- ('JSLIM','JSLIM'), ('JSLIM','임섭순') 이 COMPOSITE되어 각각 하나의 키가 되기 때문에, 중복된 값이 아니다! > OK!

-- FOREIGN KEY (TAGEL_LEVEL CONSTRAINT), REFERENCE(COL_LEVEL CONSTRAINT)
-- 부모에 의존하는 데이터이거나 NULL을 허용

-- DML (DELETE ~~)
-- REFERENCES [ON DELETE SET NULL]
-- REFERENCES [ON DELETE CASCADE]

-- DROP TABLE LOC;
CREATE TABLE LOC(
    LOCATION_ID     VARCHAR(50) PRIMARY KEY,
    LOC_DESC        VARCHAR(50)
);

-- 자식부터 제거를 해야 부모 테이블이 제거 됨
-- DROP TABLE DEPT;
CREATE TABLE DEPT(
    DEPT_ID     NUMBER(5)   PRIMARY KEY,
    DEPT_NAME   VARCHAR2(50),
    LOC_ID      VARCHAR2(50)   NOT NULL,
    FOREIGN KEY(LOC_ID) REFERENCES LOC(LOCATION_ID) -- FOREIGN KEY TABLE LEVEL로 만들어보기!
);
INSERT INTO DEPT VALUES(10, '인사팀', 10);
INSERT INTO DEPT VALUES(20, '교육팀', 20);
INSERT INTO DEPT VALUES(30, '회계팀', 20);

SELECT * FROM DEPT;

SELECT  DEPT_NAME,
        LOC_DESC
FROM    DEPT
JOIN    LOC ON(LOCATION_ID = LOC_ID);

-- DROP TABLE EMP;
CREATE TABLE EMP(
    EMP_ID      VARCHAR(50) PRIMARY KEY,
    EMP_NAME    VARCHAR(50),
    DEPT_ID     NUMBER(5)   REFERENCES DEPT(DEPT_ID)
);
-- INSERT INTO EMP VALUES('100', '홍길동', 40); -- ERROR [integrity constraint (HR.SYS_C007070) violated - parent key not found]

INSERT INTO EMP VALUES('100','GDKIM',10);
INSERT INTO EMP VALUES('200','GDKIM',NULL); -- 외래키 NULL 허용
SELECT  *   FROM EMP;

-- COMPOSITE PRIMARY KEY일 경우
-- DROP TABLE SUPER_PK CASCADE CONSTRAINTS;
CREATE TABLE SUPER_PK(
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    O_DATE  DATE,
    AMOUNT  NUMBER,             -- NUMBER 는 SIZE 줄 필요 없음
    PRIMARY KEY(U_ID, P_ID)
);
INSERT INTO SUPER_PK VALUES('GDKIM','P100',SYSDATE,10000);

--DROP TABLE SUB_FK;
CREATE TABLE SUB_FK(
    SUB_ID  VARCHAR2(20) PRIMARY KEY,
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    FOREIGN KEY(U_ID, P_ID) REFERENCES SUPER_PK(U_ID, P_ID) ON DELETE CASCADE
);

-- 부모의 PK를 받아서 본인의 FK 겸 PK로 사용하는 경우 (1:1관계 성립)
-- DROP TABLE SUB_FK;
CREATE TABLE SUB_FK(
    SUB_ID  VARCHAR2(20),
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    FOREIGN KEY(U_ID, P_ID) REFERENCES SUPER_PK(U_ID, P_ID) ON DELETE CASCADE,
    PRIMARY KEY(SUB_ID, U_ID, P_ID)
);
INSERT INTO SUB_FK VALUES('SUB100', 'GDKIM', 'P100');
SELECT * FROM SUB_FK;

-- CHECK
-- 조건을 정의할 때 변하는 값을 조건으로 사용할 수 없다
-- DROP TABLE TEST_CK;
CREATE TABLE TEST_CK(
    ID          VARCHAR2(50) PRIMARY KEY,
    SALARY      NUMBER,
--    HIRE_DATE   DATE CHECK(HIRE_DATE < SYSDATE),
    MARRIAGE    CHAR(1),
    CHECK( SALARY BETWEEN 0 AND 100 ),
    CHECK( MARRIAGE IN ('Y','N'))
);
INSERT INTO TEST_CK VALUES('100','100','N');
SELECT * FROM TEST_CK;

-- ALTER (테이블 구조 등 변경)
/*
- 컬럼 추가
ALTER TABLE TABLE_NAME ADD COLUMN_NAME DATATYPE [DEFAULT] [CONSTRAINTS];
- 컬럼 CONDITION 변경
ALTER TABLE TABLE_NAME MODIFY COLUMN_NAME [CONDITION];
*/

-- DROP
-- DROP TABLE TABLE_NAME [CASCADE CONSTRAINTS];

-- VIEW
-- 테이블의 부분집합으로 보안 측면이나 복잡한 쿼리를 단순화하기 위해서 사용
-- 단일 뷰(INSERT, UPDATE, DELETE 가능 > 원본 TABLE에 반영), 복합 뷰(I, U, D X)
-- 보통은 읽기전용
-- DROP VIEW VIEW_NAME;

/*
[기본구문]
CREATE [OR REPLACE] VIEW VIEW_NAME(ALIAS: HEADER 의 별칭부여 가능)
AS {SUBQUERY};
*/

-- 부서번호가 90인 사원의 이름, 부서번호만 접근할 수 있는 뷰를 생성한다면?
CREATE OR REPLACE VIEW V_EMP_90(이름, 부서번호)
AS SELECT   EMP_NAME,
            DEPT_ID
   FROM     EMPLOYEE
   WHERE    DEPT_ID = '90';

-- VIEW SELECT 가능
SELECT * FROM V_EMP_90;

CREATE OR REPLACE VIEW V_TEST(A, B, C)
AS SELECT   E.EMP_NAME,
            JOB_TITLE,
            V.JOBAVG
   FROM     (SELECT     JOB_ID,
                        TRUNC(AVG(SALARY), -5) AS JOBAVG
             FROM       EMPLOYEE
             JOIN       JOB USING(JOB_ID)
             GROUP BY   JOB_ID) V
   JOIN      EMPLOYEE E ON (JOBAVG = SALARY AND E.JOB_ID = V.JOB_ID)
   JOIN      JOB J ON (J.JOB_ID = E.JOB_ID);
   
SELECT * FROM V_TEST;

-- 인라인 뷰를 활용한 TOP N 분석 가능
-- 조건에 맞는 최상위 또는 최하위 레코드 N개 식별시 사용
/*
분석 원리
- 정렬
-- ROWNUM 이라는 가상의 컬럼을 이용해 정렬 순서대로 순번 부여
-- ROWNUM : EQUAL(=)로는 최상위 1건만 출력 가능 (ROWNUM=1), 등호(<,>,<=,>=) 사용해야 여러 건 출력 가능
-- 부여된 순번을 이용해서 필요한 수 만큼 식별
*/
SELECT  ROWNUM,
        EMP_NAME
FROM    EMPLOYEE;        

-- 부서별 급여 평균보다 많이 받는 사원 조회
SELECT  ROWNUM,
        EMP_NAME,
        SALARY
FROM(   SELECT  DEPT_ID,
                ROUND(AVG(SALARY), -3) AS DAVG
        FROM    EMPLOYEE
        GROUP BY DEPT_ID) V
JOIN    EMPLOYEE E ON (E.DEPT_ID = V.DEPT_ID)
WHERE   SALARY > V.DAVG
AND ROWNUM <= 5;
--ORDER BY 3 DESC;     -- 이렇게 되면 SALARY 대로 정렬은 되지만, ROWNUM이 뒤죽박죽됨!

SELECT  ROWNUM, EMP_NAME, SALARY
FROM(   SELECT  EMP_NAME,
                SALARY
        FROM(   SELECT  DEPT_ID,
                        ROUND(AVG(SALARY), -3) AS DAVG
                FROM    EMPLOYEE
                GROUP BY DEPT_ID) V
        JOIN    EMPLOYEE E ON (E.DEPT_ID = V.DEPT_ID)
        WHERE   SALARY > V.DAVG
        ORDER BY 2 DESC)
WHERE   ROWNUM = 1;

-- RANK()를 이용한 TOP-N 분석
SELECT  *
FROM(   SELECT  EMP_NAME,
                SALARY,
                RANK() OVER(ORDER BY SALARY DESC) AS RANK
        FROM    EMPLOYEE)
WHERE   RANK = 5;

-- SEQUENCE
-- 순차적으로 정수 값을 자동으로 생성해주는 객체
-- 게시글에서 글 쓸 때마다 게시글 번호가 1씩 증가하는 느낌
-- 1부터 순차적으로 무한으로 NUMBER 생성,NO CYCLE, NO CASHE
/*
CREATE SEQUENCE SEQUENCE_NAME;
CREATE SEQUENCE SEQUENCE_NAME
START WITH 10           -- 10부터 시작할래
INCREMENT BY 10         -- 10씩 증가시킬래
MAXVALUE 100;           -- 100까지 할래
*/
-- NEXTVAL, CURRVAL

CREATE SEQUENCE TEST_SEQ START WITH 10;
SELECT TEST_SEQ.NEXTVAL FROM DUAL;     -- 한번씩 돌릴 때마다 +1
SELECT TEST_SEQ.CURRVAL FROM DUAL;     -- 마지막 채번값 RETURN

DROP SEQUENCE TEST_SEQ;